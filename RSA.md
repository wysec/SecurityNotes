# RSA

RSA加密算法是一种非对称加密算法。RSA算法的安全性依赖于对极大整数做因数分解的难度。换言之，对一极大整数做因数分解愈困难，RSA算法愈安全。

## 数学基础

### 互质关系

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。

关于互质关系，有以下一些结论：

1. 任意两个质数构成互质关系，比如13和61。
2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。
3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。
4. 1和任意一个自然数是都是互质关系，比如1和99。
5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。
6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。

### 欧拉函数

任意给定正整数n，在小于等于n的正整数之中，有多少个与n构成互质关系？计算这个值的方法就叫做[欧拉函数](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)，以φ(n)表示。

例如：在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。

### 模反元素

如果两个正整数e和n互质，那么一定可以找到整数d，使得 ed-1 被n整除，或者说ed被n除的余数是1。![](http://chart.googleapis.com/chart?cht=tx&chl=ab%20%5Cequiv%201%5C%20(mod%5C%20n)&chs=40) 这时，d就叫做e的"模反元素"。

例如：3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。模反元素不止一个， 4加减11的整数倍都是3的模反元素 {...，-18，-7，4，15，26，...}，即如果d是e的模反元素，则 d+kn 都是e的模反元素。

e的 φ(n)-1 次方 / e^(φ(n)-1)，就是e的模反元素。

## 实现原理

###  生成公钥和私钥

通过这样的方式来产生一个公钥和一个私钥：
1. 随意选择两个大的质数p和q，其中p不等于q，计算**n**=pq
2. 根据欧拉函数，求得 **φ(n)** = φ(pq) = φ(p)φ(q) = (p-1)(q-1)，即求p-1和q-1的最小公倍数
3. 选择一个整数e，1<e<φ(n)，使e与 φ(n) 互质。并求得e关于φ(n)的模反元素，命名为**d**。（1<d<φ(n)，ed ≡ 1 (mod φ(n)) ）
4. 将p和q的记录销毁

(n,e)就是公钥，(n,d)就是私钥。用户将其公钥 (n,e)公开出去，而将其私钥(n,d)藏起来。

实际应用中，公钥和私钥的数据都采用[ASN.1](http://zh.wikipedia.org/zh-cn/ASN.1)格式表达。

**注意**：公钥用到的n和e是可以公开的，剩下其他都是不公开的。最关键的是d，如果被泄露则私钥就被泄露了。目前基本只要靠暴力破解d了。

###  加密消息
假设明文消息是m，则RSA的加密过程可以用下面的公式表示：

`c=m^e (mod n)`

注意：这里的n和e一起组成公钥(n,e)。

明文消息m必须是整数且小于n。对于比n大的情况，只有将其分割成若干更短的内容，分段加密。通常将明文每一个字转换为这个字的ASCII值/Unicode值，然后将这些数字连在一起组成一个数字

###  解密消息
假设密文消息是c，RSA的解密过程可以用下面的公式表示：

`m=c^d (mod n)`

注意：这里的n和d一起组成私钥(n,d)。

## 计算过程

下面用具体的数字来实践RSA密钥对生成、加密以及解密过程。为了计算方便，这里使用比较小的数做演示，实际为了安全性都会使用非常大的数字。

1. 选择两个质数，比如p=61，q=53，则n=p*q=3233。（二进制是 110010100001，此算法是12位的，实际算法通常是2048位，位数越长越安全）。
2. 计算φ(n)=φ(p-1,q-1)=φ(60,52)=780
3. 求e，其中1<e<780，e还要与780互质，这样的数有多个，比如7、9、11、14、17...。这里选e=17
4. 求d=413。计算过程：根据公式 `d*e modeφ(n)=1` ， 等价于 `e*d - 1 = y*φ(n)` ( y 为整数），实际就是对此二元一次方程求解`e*x - φ(n)*y = 1`，即 17*x - 780*y = 1，此方程可用[扩展欧几里得算法](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)求解，可算出一组整数解，得到 (x，y)= (413，9)，即 d = 413。
5. 这样就得到公钥是(n = 3233, e = 17)，私钥是(n = 3233, d = 413)
6. 假如明文是m=65，加密得到密文c=65^17 (mod 3233)=2790
7. 解密密文得到明文m=2790^413 (mod 3233)=65


### 示例

比如甲向乙发送汉字“中”，就要使用乙的公钥加密汉字"中"， 以UTF-8方式编码为 [e4 b8 ad]，转为 10 进制为 [228,184,173]。要想使用公钥（n，e) = (3233, 17) 加密，要求被加密的数字必须小于 n。因此将“中”字折为三个字节 [228,184,173]，分别对三个字节加密。

计算 [228,184,173]的密文：

228^17(mode 3233) = 293

184^17(mode 3233) = 3112

173^17(mode 3233) = 429

解密：

293^413(mode 3233) = 228

3112^413(mode 3233) = 184

429^413(mode 3233) = 173

## 数据分组

RSA对数据是分组加解密的，必须确保该分组可以保存的最大数值要小于n的位数。比如，如果p和q都是200位数字的素数，则n的结果将小于400位。因而，所选择的分组所能保存的最大值应该要以是接近于400。在实践中，通常选择的位数都是比n小的2的整数次幂。比如，如果n是209，要选择的分组大小就是7位，因为2^7 = 128比209小，但2^8 = 256又大于209。

## 填充

为什么需要填充？

由于RSA是分组加密的，这就必然导致最后一组和模长度不一致，这就需要对不足的部分进行填充了。另外，相同的明文加密后是相同的密文，这也是不安全的。

每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是key长度。

<u>RSA加密常用的填充模式有三种：</u>

### RSA_NO_PADDING

无填充，其实就是在高位填充 00。输入可以和n一样长，如果输入明文过长，则需要分组&填充。

> Bouncy Castle默认使用的此填充方式。

### RSA_PKCS1_PADDING

符号和缩写：
- BT - block type
- D - data
- EB - encryption block
- PS - padding string
- k - length of modulus in octets/模长

PKCS #1 填充的格式：`EB = 00 || BT || PS || 00 || D` 。
- BT表示加密块的结构，其值可以是00、01或02，对于私钥的操作其可以是00或01，对于公钥的操作其是02。//私钥推荐用01。
- PS应由k-3-D位字节构成，对于BT是00，其值是00；对于BT是01，其值是FF；于BT是02，其值是随机的非零值。它使EB的长度等于k。//*注意*：当BT是00时，D必须以非零开始或者已知其长度，以便可以明确的解析EB。PS是8位字节。
- D的长度不应该超过k-11字节。

> Java默认的RSA实现是`RSA/None/PKCS1Padding`（Cipher cipher = Cipher.getInstance("RSA")），就是此填充方式。使用相同公钥加密时，每次加密的密文是不同的；而使用相同的私钥加密时，每次加密的密文是相同的。

### RSA_PKCS1_OAEP_PADDING
最佳非对称加密填充

**名词定义：**

- n 是RSA模的位数
- k0、k1 是协议的固定整数
- m 是明文消息，(n-k0-k1) 位字符串
- G、H 是随机预言（random oracle），如加密散列函数
- ⊕ 是异或操作

**编码方式：**

![](https://upload.wikimedia.org/wikipedia/commons/1/18/Oaep-diagram-20080305.png)
1. 消息被用k1个0填充*n-k0*位长
2. r是随机产生的k0位长字符串
3. G将r的k0位扩展为*n-k0*位
4. X = m00...0 ⊕ G(r)
5. H将X的n-k0位减少到k0位
6. Y = r ⊕ H(X)
7. 输入就是X||Y

> 编码后的消息就可以用RSA加密。使用OAEP编码可避免RSA的确定性特性。

**解码方法：**

1. 恢复随机字符串 r = Y ⊕ H(X)
2. 恢复消息 m00...0 = X ⊕ G(r)


## 参考资料

[RSA加密算法](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)

[RSA算法原理（一）](https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

[RSA算法原理（二）](https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

[一文搞懂 RSA 算法](https://zhuanlan.zhihu.com/p/44185847)

[数据加密--详解 RSA加密算法 原理与实现](https://www.cnblogs.com/idreamo/p/9411265.html)

[RSA非对称加解密算法填充方式（Padding）](https://blog.csdn.net/makenothing/article/details/88429511)

[PKCS #1: RSA Encryption Version 1.5](https://tools.ietf.org/html/rfc2313)

[Optimal asymmetric encryption padding](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding)

[Improving the security of RSA with OAEP](https://medium.com/blue-space/improving-the-security-of-rsa-with-oaep-e854a5084918)